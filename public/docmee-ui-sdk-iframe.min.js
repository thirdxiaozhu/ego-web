"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };

  // node_modules/.pnpm/query-string@9.1.1/node_modules/query-string/base.js
  var base_exports = {};
  __export(base_exports, {
    exclude: () => exclude,
    extract: () => extract,
    parse: () => parse,
    parseUrl: () => parseUrl,
    pick: () => pick,
    stringify: () => stringify,
    stringifyUrl: () => stringifyUrl
  });

  // node_modules/.pnpm/decode-uri-component@0.4.1/node_modules/decode-uri-component/index.js
  var token = "%[a-f0-9]{2}";
  var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
  var multiMatcher = new RegExp("(" + token + ")+", "gi");
  function decodeComponents(components, split) {
    try {
      return [decodeURIComponent(components.join(""))];
    } catch {
    }
    if (components.length === 1) {
      return components;
    }
    split = split || 1;
    const left = components.slice(0, split);
    const right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }
  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch {
      let tokens = input.match(singleMatcher) || [];
      for (let i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join("");
        tokens = input.match(singleMatcher) || [];
      }
      return input;
    }
  }
  function customDecodeURIComponent(input) {
    const replaceMap = {
      "%FE%FF": "\uFFFD\uFFFD",
      "%FF%FE": "\uFFFD\uFFFD"
    };
    let match = multiMatcher.exec(input);
    while (match) {
      try {
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch {
        const result = decode(match[0]);
        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }
      match = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    const entries = Object.keys(replaceMap);
    for (const key of entries) {
      input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
  }
  function decodeUriComponent(encodedURI) {
    if (typeof encodedURI !== "string") {
      throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
      return decodeURIComponent(encodedURI);
    } catch {
      return customDecodeURIComponent(encodedURI);
    }
  }

  // node_modules/.pnpm/filter-obj@5.1.0/node_modules/filter-obj/index.js
  function includeKeys(object, predicate) {
    const result = {};
    if (Array.isArray(predicate)) {
      for (const key of predicate) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor?.enumerable) {
          Object.defineProperty(result, key, descriptor);
        }
      }
    } else {
      for (const key of Reflect.ownKeys(object)) {
        const descriptor = Object.getOwnPropertyDescriptor(object, key);
        if (descriptor.enumerable) {
          const value = object[key];
          if (predicate(key, value, object)) {
            Object.defineProperty(result, key, descriptor);
          }
        }
      }
    }
    return result;
  }

  // node_modules/.pnpm/split-on-first@3.0.0/node_modules/split-on-first/index.js
  function splitOnFirst(string, separator) {
    if (!(typeof string === "string" && typeof separator === "string")) {
      throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (string === "" || separator === "") {
      return [];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
      return [];
    }
    return [
      string.slice(0, separatorIndex),
      string.slice(separatorIndex + separator.length)
    ];
  }

  // node_modules/.pnpm/query-string@9.1.1/node_modules/query-string/base.js
  var isNullOrUndefined = (value) => value === null || value === void 0;
  var strictUriEncode = (string) => encodeURIComponent(string).replaceAll(/[!'()*]/g, (x) => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);
  var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case "index": {
        return (key) => (result, value) => {
          const index = result.length;
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), "[", index, "]"].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), "[", encode(index, options), "]=", encode(value, options)].join("")
          ];
        };
      }
      case "bracket": {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), "[]"].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), "[]=", encode(value, options)].join("")
          ];
        };
      }
      case "colon-list-separator": {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              [encode(key, options), ":list="].join("")
            ];
          }
          return [
            ...result,
            [encode(key, options), ":list=", encode(value, options)].join("")
          ];
        };
      }
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSeparator = options.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode(key, options), keyValueSeparator, encode(value, options)].join("")];
          }
          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };
      }
      default: {
        return (key) => (result, value) => {
          if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [
              ...result,
              encode(key, options)
            ];
          }
          return [
            ...result,
            [encode(key, options), "=", encode(value, options)].join("")
          ];
        };
      }
    }
  }
  function parserForArrayFormat(options) {
    let result;
    switch (options.arrayFormat) {
      case "index": {
        return (key, value, accumulator) => {
          result = /\[(\d*)]$/.exec(key);
          key = key.replace(/\[\d*]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      }
      case "bracket": {
        return (key, value, accumulator) => {
          result = /(\[])$/.exec(key);
          key = key.replace(/\[]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [...accumulator[key], value];
        };
      }
      case "colon-list-separator": {
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [...accumulator[key], value];
        };
      }
      case "comma":
      case "separator": {
        return (key, value, accumulator) => {
          const isArray = typeof value === "string" && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray && decode2(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options) : value;
          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item) => decode2(item, options)) : value === null ? value : decode2(value, options);
          accumulator[key] = newValue;
        };
      }
      case "bracket-separator": {
        return (key, value, accumulator) => {
          const isArray = /(\[])$/.test(key);
          key = key.replace(/\[]$/, "");
          if (!isArray) {
            accumulator[key] = value ? decode2(value, options) : value;
            return;
          }
          const arrayValue = value === null ? [] : decode2(value, options).split(options.arrayFormatSeparator);
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [...accumulator[key], ...arrayValue];
        };
      }
      default: {
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [...[accumulator[key]].flat(), value];
        };
      }
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options) {
    if (options.decode) {
      return decodeUriComponent(value);
    }
    return value;
  }
  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }
    if (typeof input === "object") {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map((key) => input[key]);
    }
    return input;
  }
  function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }
    return input;
  }
  function getHash(url) {
    let hash = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }
    return hash;
  }
  function parseValue(value, options, type) {
    if (type === "string" && typeof value === "string") {
      return value;
    }
    if (typeof type === "function" && typeof value === "string") {
      return type(value);
    }
    if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      return value.toLowerCase() === "true";
    }
    if (type === "number" && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      return Number(value);
    }
    if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      return Number(value);
    }
    return value;
  }
  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input.slice(queryStart + 1);
  }
  function parse(query, options) {
    options = {
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false,
      types: /* @__PURE__ */ Object.create(null),
      ...options
    };
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    const returnValue = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return returnValue;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return returnValue;
    }
    for (const parameter of query.split("&")) {
      if (parameter === "") {
        continue;
      }
      const parameter_ = options.decode ? parameter.replaceAll("+", " ") : parameter;
      let [key, value] = splitOnFirst(parameter_, "=");
      if (key === void 0) {
        key = parameter_;
      }
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options.arrayFormat) ? value : decode2(value, options);
      formatter(decode2(key, options), value, returnValue);
    }
    for (const [key, value] of Object.entries(returnValue)) {
      if (typeof value === "object" && value !== null && options.types[key] !== "string") {
        for (const [key2, value2] of Object.entries(value)) {
          const type = options.types[key] ? options.types[key].replace("[]", "") : void 0;
          value[key2] = parseValue(value2, options, type);
        }
      } else if (typeof value === "object" && value !== null && options.types[key] === "string") {
        returnValue[key] = Object.values(value).join(options.arrayFormatSeparator);
      } else {
        returnValue[key] = parseValue(value, options, options.types[key]);
      }
    }
    if (options.sort === false) {
      return returnValue;
    }
    return (options.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options.sort)).reduce((result, key) => {
      const value = returnValue[key];
      result[key] = Boolean(value) && typeof value === "object" && !Array.isArray(value) ? keysSorter(value) : value;
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  function stringify(object, options) {
    if (!object) {
      return "";
    }
    options = {
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      ...options
    };
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const [key, value] of Object.entries(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = value;
      }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
      keys.sort(options.sort);
    }
    return keys.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode(key, options);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === "bracket-separator") {
          return encode(key, options) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode(key, options) + "=" + encode(value, options);
    }).filter((x) => x.length > 0).join("&");
  }
  function parseUrl(url, options) {
    options = {
      decode: true,
      ...options
    };
    let [url_, hash] = splitOnFirst(url, "#");
    if (url_ === void 0) {
      url_ = url;
    }
    return {
      url: url_?.split("?")?.[0] ?? "",
      query: parse(extract(url), options),
      ...options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode2(hash, options) } : {}
    };
  }
  function stringifyUrl(object, options) {
    options = {
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true,
      ...options
    };
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = extract(object.url);
    const query = {
      ...parse(queryFromUrl, { sort: false }),
      ...object.query
    };
    let queryString = stringify(query, options);
    queryString &&= `?${queryString}`;
    let hash = getHash(object.url);
    if (typeof object.fragmentIdentifier === "string") {
      const urlObjectForFragmentEncode = new URL(url);
      urlObjectForFragmentEncode.hash = object.fragmentIdentifier;
      hash = options[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
  }
  function pick(input, filter, options) {
    options = {
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false,
      ...options
    };
    const { url, query, fragmentIdentifier } = parseUrl(input, options);
    return stringifyUrl({
      url,
      query: includeKeys(query, filter),
      fragmentIdentifier
    }, options);
  }
  function exclude(input, filter, options) {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return pick(input, exclusionFilter, options);
  }

  // node_modules/.pnpm/query-string@9.1.1/node_modules/query-string/index.js
  var query_string_default = base_exports;

  // @types/index.d.ts
  var CreatorType = /* @__PURE__ */ ((CreatorType2) => {
    CreatorType2[CreatorType2["AI_GEN"] = 1] = "AI_GEN";
    CreatorType2[CreatorType2["UPLOAD_FILES"] = 2] = "UPLOAD_FILES";
    CreatorType2[CreatorType2["UPLOAD_MIND"] = 3] = "UPLOAD_MIND";
    CreatorType2[CreatorType2["WORD"] = 4] = "WORD";
    CreatorType2[CreatorType2["URL"] = 5] = "URL";
    CreatorType2[CreatorType2["CONTENT"] = 6] = "CONTENT";
    CreatorType2[CreatorType2["MD"] = 7] = "MD";
    return CreatorType2;
  })(CreatorType || {});

  // utils/index.ts
  var docmeeContext = {
    BASE_URL: "https://iframe.docmee.cn"
  };
  var pageKeyHrefMap = {
    dashboard: `sdk-ui/dashboard`,
    editor: `sdk-ui/editor`,
    creator: `sdk-ui/creator/0`,
    "creator-v2": `sdk-ui/creator-v2`,
    customTemplate: `sdk-ui/custom-template`,
    templateCreator: `sdk-ui/custom-template-creator`,
    templateMarker: `sdk-ui/marker`
  };
  var getPageKey = (key, creatorVersion) => {
    if (/^(creator)/.test(key)) {
      let suffix = "";
      if (creatorVersion) {
        suffix = creatorVersion === "v1" ? "" : `-${creatorVersion}`;
      }
      key = `creator${suffix}`;
    }
    return key;
  };
  var getBaseURL = () => {
    return docmeeContext["BASE_URL"];
  };
  var getPathname = (key, creatorVersion) => {
    const pathname = pageKeyHrefMap[key];
    return pathname;
  };
  var getIframeUrl = (key, creatorVersion) => {
    key = getPageKey(key, creatorVersion);
    const BASE_URL = getBaseURL(), pathname = getPathname(key, creatorVersion);
    return BASE_URL.endsWith("/") ? `${BASE_URL}${pathname}` : `${BASE_URL}/${pathname}`;
  };

  // index.ts
  var DocmeeUI = class {
    creatorVersion;
    token;
    container;
    docmeeHref = getIframeUrl("dashboard");
    query = { iframe: "1" };
    iframe = null;
    onMessage;
    iframeMounted = false;
    initInterval = null;
    constructor({
                  token: token2,
                  page = "dashboard",
                  container,
                  pptId,
                  onMessage,
                  // @ts-ignore
                  DOMAIN,
                  ...otherOptions
                }) {
      this.onMessage = onMessage;
      this.creatorVersion = otherOptions.creatorVersion;
      if (typeof container == "string") {
        this.container = document.getElementById(container);
      } else {
        this.container = container;
      }
      if (location.protocol.startsWith("file")) {
        console.log(
          "%c %s",
          "color: red; background-color: #f7c600",
          "\u{1F534} \u4E0D\u80FD\u5728file\u534F\u8BAE\u4E0B\u8FD0\u884C\uFF0C\u8BF7\u542F\u52A8\u4E00\u4E2Ahttp\u670D\u52A1\u6765\u8FD0\u884C\uFF01 \u{1F534} "
        );
      }
      if (!token2) {
        console.log("%c \u521D\u59CB\u5316\u65F6\uFF0Ctoken\u4E0D\u80FD\u4E3A\u7A7A\uFF01", "color: #d7514f; background-color: #2e2e2e");
      }
      if (DOMAIN) {
        docmeeContext.BASE_URL = DOMAIN;
      }
      this.init({ token: token2, page, pptId, ...otherOptions });
    }
    on(eventName, callback) {
      this._eventListeners[eventName] = [...this._eventListeners[eventName] || [], callback];
    }
    _eventListeners = {
      mounted: [],
      beforeGenerate: [],
      beforeCreateCustomTemplate: [],
      "user-info": [],
      charge: [],
      afterCreateCustomTemplate: [],
      afterGenerate: [],
      beforeDownload: [],
      error: [],
      manuallySavePPT: [],
      toggleGenerateMode: [],
      pageChange: [],
      changeSlideIndex: [],
      "invalid-token": [],
      beforeCreatePpt: []
    };
    _postMessage(message) {
      if (!this.iframe?.contentWindow) {
        console.log(this.iframe?.contentWindow);
        console.error("iframe\u672A\u6302\u8F7D\uFF01");
      }
      this.iframe?.contentWindow?.postMessage(message, this.docmeeHref);
    }
    init({ token: token2, page = "dashboard", ...otherOptions }) {
      if (page === "editor" && !otherOptions.pptId) throw new Error("\u521D\u59CB\u5316editor\u9875\u9762\u65F6\uFF0C\u5FC5\u987B\u4F20\u5165pptId");
      this.query = Object.assign({}, this.query, otherOptions);
      this.docmeeHref = getIframeUrl(page, otherOptions.creatorVersion);
      this.updateToken(token2);
      this._initIframe(true);
    }
    // 初始化iframe
    _initIframe(parseTokenByMessage) {
      const container = this.container;
      const iframe = document.createElement("iframe");
      const targetOrigin = `${location.protocol}//${location.host}`;
      const iframeSource = query_string_default.stringifyUrl({
        url: this.docmeeHref,
        query: parseTokenByMessage ? { iframe: 1, targetOrigin } : this.query
      });
      iframe.src = iframeSource;
      iframe.style.width = "100%";
      iframe.style.height = "100%";
      iframe.style.border = "0";
      iframe.style.outline = "none";
      iframe.style.padding = "0px";
      iframe.setAttribute("allowfullscreen", "true");
      this.iframe = iframe;
      this.iframeMounted = false;
      container.innerHTML = "";
      container.appendChild(iframe);
      window.addEventListener("message", async (event) => {
        if (event.source !== this.iframe?.contentWindow) return;
        const message = event.data;
        if (!message.type) return;
        if (parseTokenByMessage) {
          if (message.type === "mounted" || message.type === "invalid-token") {
            this.iframeMounted = true;
            if (message.type === "mounted") {
              this._postMessage({
                type: "transParams",
                data: this.query
              });
            }
          }
        }
        if (message.type === "user-info") {
          this.iframeMounted = true;
        }
        let res;
        res = await this.onMessage?.(message);
        const onCallbacks = this._eventListeners[message.type];
        if (onCallbacks?.length > 0) {
          onCallbacks.forEach((callback) => {
            try {
              const result = callback?.(message);
              if (result !== void 0) {
                res = result;
              }
            } catch {
            }
          });
        }
        if (message.type.startsWith("before")) {
          if (res == void 0) res = true;
          this._postMessage({ data: res, type: `recover_${message.type}` });
        }
      });
      this.iframe.addEventListener("load", () => {
        let infoAPiCount = 0;
        setTimeout(() => {
          if (this.iframeMounted) return;
          this.initInterval = setInterval(() => {
            if (this.iframeMounted || infoAPiCount >= 5) {
              infoAPiCount = 0;
              return clearInterval(this.initInterval);
            }
            if (parseTokenByMessage) {
              this._postMessage({
                type: "transParams",
                data: this.query
              });
            }
            infoAPiCount++;
          }, 200);
        }, 300);
      });
    }
    /**
     * 更新用户token
     * @param {string} latestToken 新的token
     */
    updateToken(latestToken) {
      const regex = /(a|s)k_.+/;
      if (!regex.test(latestToken)) {
        console.error("token \u9519\u8BEF\uFF01");
      }
      this.token = latestToken;
      this.query.token = latestToken;
      if (this.iframeMounted) {
        this._postMessage({
          type: "transParams",
          data: {
            token: latestToken
          }
        });
      }
    }
    /**
     * 卸载iframe
     */
    destroy() {
      this.container.innerHTML = "";
    }
    /**
     * 发送消息
     */
    sendMessage(data) {
      this._postMessage({ type: "message", data });
    }
    getInfo() {
      this._postMessage({ type: "getInfo" });
    }
    /**
     * 跳转到指定页面
     *
     */
    navigate({ page, pptId, templateId }) {
      const href = pageKeyHrefMap[page];
      if (!href) throw new Error(`\u9875\u9762${page} \u4E0D\u5B58\u5728`);
      const key = getPageKey(page, this.creatorVersion);
      this._postMessage({
        type: "nav",
        data: {
          page: key,
          token: this.token,
          pptId,
          templateId
        }
      });
    }
    /**
     * 修改用于 生成PPT的内容
     * @param data: any
     * @param now
     */
    changeCreatorData(data, now = false) {
      this._postMessage({
        type: "transParams",
        data: { creatorData: { ...data, createNow: now } }
      });
    }
    /**
     * 修改当前编辑中的PPT的模版
     *
     * 该方法只在编辑页面生效
     * @param templateId  模版ID
     */
    updateTemplate(templateId) {
      this._postMessage({
        type: "changeTemplateById",
        data: { templateId }
      });
    }
    /**
     * 打开模版选择弹窗
     *
     * 该方法只在编辑页面生效
     */
    showTemplateDialog(type = "system") {
      this._postMessage({
        type: "showTemplateDialog",
        data: { type }
      });
    }
    /**
     * 获取当前编辑中的PPT的信息，PPT数据将在回调中返回
     *
     * 该方法只在编辑页面生效
     */
    getCurrentPptInfo() {
      this._postMessage({
        type: "getCurrentPptInfo"
      });
    }
    /**
     * 导入外部CSS文件
     *
     * @param css css样式，可以传递标准的css规则字符串，也可以使用能够访问的url
     */
    importCSS(css) {
      this._postMessage({ type: "importCSS", data: { css } });
    }
  };
  window.DocmeeUI = DocmeeUI;
})();
//# sourceMappingURL=index.global.js.map
